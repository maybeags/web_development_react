# useReducer / useContext 활용 예제

## useReducer의 문제점

: props drilling 문제가 있을 수 있다.
![drilling01](./drilling.webp)

어제 저희가 작성한 예제에서 LoginForm 컴포넌트에서 state와 dispatch를 사용하기 위해 App 컴포넌트에서부터 props로 값을 내려보내줘야 했습니다.

```jsx
function App() {

  const [ state, dispatch ] = useReducer(Reducer, { isLogin: false, message : '', })  // 여기서 선언했고

  return (
    <div>
      {state.isLogin ? (
        <>
          <strong>welcome 🎈</strong>
          <button onClick={() => dispatch({type: "LOGOUT"})}>로그아웃</button>
        </>
      ) : (
        <LoginForm state={state} dispatch={dispatch} />   // 여기로 내려보내준 것을 이미지화했습니다.
      )}
    </div>
  );
}
```

이상의 코드가 App 컴포넌트에서 useReducer를 통해 생성한 state / dispatch를 LoginForm이라는 자식 컴포넌트에 전달한 코드 사례에 해당합니다.
그렇다면 상태관리도 하면서 props drilling의 문제를 해결하려면 어떡해야 할까?
-> useContext를 사용하면 된다.

![drilling02](./drilling02.webp)

이상의 이미지는 props drilling의 대표적은 도식화에 해당합니다. 즉 단계적으로 일일이 props를 넘겨줌으로써 해당 props를 사용하지 않는 컴포넌트 들에도 데이터가 제공되는 문제가 있습니다.

다만 저희는 부모에서 정의하고 바로 자식 컴포넌트에서 사용했습니다.


```jsx
import { createContext, useReducer } from "react";
import Reducer from "../reducer/Reducer";

const INITIAL_STATE = { isLogin: false, message: '' };

export const Context = createContext(INITIAL_STATE);

export const ContextProvider = ({ children }) => {
  const [state, dispatch] = useReducer(Reducer, INITIAL_STATE);

  return(
    <Context.Provider
      value= {{
        state,
        dispatch,
      }}
    >
      {children}
    </Context.Provider>
  );
}

export default Context;
```

useContext의 사용을 위해 Context.jsx에 이상과 같이 작성했습니다.
초기값으로 들어갈 상태를 INITIAL_STATE라는 상수 이름에 대입했습니다.
createContext 안에 넣어서, Context 객체를 생성했습니다.

ContextProvider 컴포넌트를 생성하고 useReducer 안에 첫 번째 argument로 reducer 함수(Reducer), 두 번째 argument로 INITIAL_STATE를 넣어서 전달합니다(provider).

ContextProvider 컴포넌트는 Context.Provider를 반환하는데, value 속성을 통해 하위 컴포넌트에 전달할 값을 지정해줬습니다.

![drillingContext](./drillingContext.webp)